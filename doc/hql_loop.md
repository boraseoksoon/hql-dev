# HQL Loop Constructs

HQL’s iteration model is built on a fundamental `loop/recur` mechanism, which is
implemented as a core special form. From this core, higher-level looping
constructs are built as macros. This design allows you to use a pure, explicit
loop at its core and extend it with familiar imperative-style forms.

---

## 1. Fundamental Loop/Recur

**Goal:**\
Provide a minimal, explicit tail‑recursive mechanism where loop state is passed
via bindings.

**User-Level Syntax:**

```lisp
(loop (i 0)
  (when (< i 5)
    (print "Iteration:" i)
    (recur (+ i 1))))
```

**Explanation:**

- `(loop (i 0))` initializes the binding `i` to `0`.
- `when (< i 5)` checks the condition.
- `recur (+ i 1)` makes a tail-recursive call, passing the updated value of `i`.

---

## 2. Imperative-Style while Loop (Macro-Based)

**Goal:**\
Provide a familiar imperative-style `while` loop that internally expands to
`loop/recur`.

**Final User-Level Syntax:**

```lisp
;; First, declare a mutable binding for the counter using var.
(var count 0)

(while (< count 5)
  (print "While iteration:" count)
  (set! count (+ count 1)))

(print "Final count:" count)
```

**Explanation:**

- `var count 0` declares `count` as a mutable binding (compiled to JavaScript’s
  `let`).
- The `while` macro (implemented on top of `loop/recur`) repeatedly checks if
  `count` is less than `5`.
- `set! count (+ count 1)` updates the mutable binding.
- The final value of `count` is available after the loop completes.

---

## 3. for Loop (Collection Iteration)

**Goal:**\
Provide a concise “for‑each” loop for iterating over a collection. In this
example, a `range` function is used to generate a sequence of numbers.

**Final User-Level Syntax:**

```lisp
;; Assume we have a range function that generates a sequence of numbers.
(for (i (range 10))
  (print "For loop iteration, i:" i))
```

**Explanation:**

- `(range 10)` returns a sequence of numbers from `0` to `9`.
- The `for` macro iterates over this sequence.
- In each iteration, the current value is bound to `i`, and the body is executed
  (here, printing `i`).
- This syntax resembles a “for‑each” loop found in many mainstream languages.

---

## Summary

- **Fundamental Loop/Recur:**\
  Core mechanism that explicitly passes loop state and guarantees tail-call
  optimization.\
  **Example:**
  ```lisp
  (loop (i 0)
    (when (< i 5)
      (print "Iteration:" i)
      (recur (+ i 1))))
  ```

- **while Loop (Macro-Based):**\
  Imperative-style loop that expands into `loop/recur`.\
  Requires mutable bindings (declared with `var`) for loop control.\
  **Example:**
  ```lisp
  (var count 0)
  (while (< count 5)
    (print "While iteration:" count)
    (set! count (+ count 1)))
  (print "Final count:" count)
  ```

- **for Loop (Collection Iteration):**\
  Designed for iterating over sequences, such as those generated by a `range`
  function.\
  Provides a concise “for‑each” syntax.\
  **Example:**
  ```lisp
  (for (i (range 10))
    (print "For loop iteration, i:" i))
  ```

This loop series provides a pure, minimal core (`loop/recur`) on which more
familiar imperative-style loops (`while`, `for`, `range`) are built as macros.
All examples use only parentheses, and mutable loop variables are explicitly
declared with `var`.
