// Auto-generated file containing embedded macro sources
// Generated by: tools/embed_macros.ts

// Helper function to check if a path refers to an embedded file
export function isEmbeddedFile(path: string): boolean {
  // Normalize the path to check
  const normalizedPath = path.replace(/\\/g, '/');
  
  // Check if it matches any embedded file
  for (const key of Object.keys(EMBEDDED_MACROS)) {
    if (normalizedPath.includes(key) || normalizedPath.endsWith(key.split('/').pop()!)) {
      return true;
    }
  }
  
  // Also check for stdlib files
  return normalizedPath.includes('core/lib/stdlib/') || 
         normalizedPath.includes('lib/stdlib/');
}

// Get embedded file content
export function getEmbeddedContent(path: string): string | undefined {
  // Normalize the path
  const normalizedPath = path.replace(/\\/g, '/');
  
  // Direct match
  if (EMBEDDED_MACROS[normalizedPath as keyof typeof EMBEDDED_MACROS]) {
    return EMBEDDED_MACROS[normalizedPath as keyof typeof EMBEDDED_MACROS];
  }
  
  // Try to find by partial match
  for (const [key, content] of Object.entries(EMBEDDED_MACROS)) {
    if (normalizedPath.includes(key) || normalizedPath.endsWith(key.split('/').pop()!)) {
      return content;
    }
  }
  
  return undefined;
}

export const EMBEDDED_MACROS = {
  "core/lib/macro/core.hql": `(macro or (a b)
  \`(if ~a ~a ~b))

(macro and (x y)
  \`(if ~x ~y ~x))

(macro not (x)
  \`(if ~x false true))

(macro unless (test & body)
  \`(if ~test
       nil
       (do ~@body)))

(macro inc (x)
  \`(+ ~x 1))

(macro dec (x)
  \`(- ~x 1))

(macro when (test & body)
  \`(if ~test
       (do ~@body)
       nil))

(macro when-let (binding & body)
  (let (var-name (first binding)
        var-value (second binding))
    \`((lambda (~var-name)
         (when ~var-name
             ~@body))
       ~var-value)))

(macro print (& args)
  \`(console.log ~@args))

(macro cons (item lst)
  \`(concat (list ~item) ~lst))

(fn concat (arr1 arr2)
  (js-call arr1 "concat" arr2))

(macro str (& args)
  (cond
    ((empty? args) \`"")
    ((= (length args) 1) \`(+ "" ~(first args)))
    (true \`(+ ~@args))))

(macro empty? (coll)
  \`(or (nil? ~coll)
       (= (length ~coll) 0)))

(macro contains? (coll key)
  \`(js-call ~coll "has" ~key))

(macro nth (coll index)
  \`(get ~coll ~index))

(macro if-let (binding then-expr else-expr)
  (let (var-name (first binding)
        var-value (second binding))
    \`((lambda (~var-name)
         (if ~var-name
             ~then-expr
             ~else-expr))
       ~var-value)))

;; no distinction between list and vector now.
(macro list (& items)
  \`[~@items])

(macro nil? (x)
  \`(= ~x null))

(macro length (coll)
  \`(if (= ~coll null)
       0
       (js-get ~coll "length")))

;; Simple implementations of list operations
(macro first (coll)
  \`(get ~coll 0))

(macro second (coll)
  \`(if (and (not (nil? ~coll)) (> (length ~coll) 1))
      (nth ~coll 1)
      nil))

(macro rest (coll)
  \`(js-call ~coll "slice" 1))

(macro next (coll)
  \`(if (< (js-get ~coll "length") 2)
       null
       (js-call ~coll "slice" 1)))

(macro seq (coll)
  \`(if (= (js-get ~coll "length") 0)
       null
       ~coll))`,

  "core/lib/macro/loop.hql": `;; ====================================================
;; HQL Loop Constructs Library - Enhanced Version
;; This library implements a series of looping constructs
;; built on the fundamental loop/recur mechanism
;; ====================================================

;; ====================
;; 1. While Loop
;; ====================

;; Simple while loop - repeats body as long as condition is true
;; Example usage:
;; (var count 0)
;; (while (< count 5)
;;   (print count)
;;   (set! count (+ count 1)))
(macro while (condition & body)
  \`(loop ()
     (if ~condition
       (do
         ~@body
         (recur))
       nil)))

;; ====================
;; 2. Repeat Loop
;; ====================

;; Simple repeat loop - repeats body a specific number of times
;; Example usage:
;; (repeat 3 (print "hello"))
(macro repeat (count & body)
  \`(loop (i 0)
     (if (< i ~count)
       (do
         ~@body
         (recur (+ i 1)))
       nil)))

;; ====================
;; 3. Enhanced For Loop
;; ====================

;; Unified for loop - handles both positional and named arguments
;; Supports multiple styles:
;;
;; Traditional style:
;; (for (i 10) ...) - iterates i from 0 to 9
;; (for (i 5 10) ...) - iterates i from 5 to 9
;; (for (i 0 10 2) ...) - iterates i from 0 to 9 by steps of 2
;;
;; Named parameter style (using symbols, not strings):
;; (for (i to: 10) ...) - iterates i from 0 to 9
;; (for (i from: 5 to: 10) ...) - iterates i from 5 to 9
;; (for (i from: 0 to: 10 by: 2) ...) - iterates i from 0 to 9 by steps of 2
(macro for (binding & body)
  (let (var (first binding))
    (cond
      ;; Case: (for (i to: 10) ...)
      ((and (= (length binding) 3)
            (symbol? (nth binding 1))
            (= (name (nth binding 1)) "to:"))
       \`(loop (~var 0)
          (if (< ~var ~(nth binding 2))
            (do
              ~@body
              (recur (+ ~var 1)))
            nil)))
      
      ;; Case: (for (i to: 10 by: 2) ...)
      ((and (= (length binding) 5)
            (symbol? (nth binding 1))
            (= (name (nth binding 1)) "to:")
            (symbol? (nth binding 3))
            (= (name (nth binding 3)) "by:"))
       \`(loop (~var 0)
          (if (< ~var ~(nth binding 2))
            (do
              ~@body
              (recur (+ ~var ~(nth binding 4))))
            nil)))
      
      ;; Case: (for (i from: 0 to: 10) ...)
      ((and (= (length binding) 5)
            (symbol? (nth binding 1))
            (= (name (nth binding 1)) "from:")
            (symbol? (nth binding 3))
            (= (name (nth binding 3)) "to:"))
       \`(loop (~var ~(nth binding 2))
          (if (< ~var ~(nth binding 4))
            (do
              ~@body
              (recur (+ ~var 1)))
            nil)))
      
      ;; Case: (for (i from: 0 to: 10 by: 2) ...)
      ((and (= (length binding) 7)
            (symbol? (nth binding 1))
            (= (name (nth binding 1)) "from:")
            (symbol? (nth binding 3))
            (= (name (nth binding 3)) "to:")
            (symbol? (nth binding 5))
            (= (name (nth binding 5)) "by:"))
       \`(loop (~var ~(nth binding 2))
          (if (< ~var ~(nth binding 4))
            (do
              ~@body
              (recur (+ ~var ~(nth binding 6))))
            nil)))
      
      ;; Original cases unchanged
      ;; Case: (for (i 10) ...) - iterates i from 0 to 9
      ((= (length binding) 2)
       \`(loop (~var 0)
          (if (< ~var ~(second binding))
            (do
              ~@body
              (recur (+ ~var 1)))
            nil)))
      
      ;; Case: (for (i 5 10) ...) - iterates i from 5 to 9
      ((= (length binding) 3)
       \`(loop (~var ~(second binding))
          (if (< ~var ~(nth binding 2))
            (do
              ~@body
              (recur (+ ~var 1)))
            nil)))
      
      ;; Case: (for (i 0 10 2) ...) - iterates i from 0 to 9 by steps of 2
      ((= (length binding) 4)
       \`(loop (~var ~(second binding))
          (if (< ~var ~(nth binding 2))
            (do
              ~@body
              (recur (+ ~var ~(nth binding 3))))
            nil)))
      
      ;; Default case - better error handling
      (true \`(throw (str "Invalid 'for' loop binding: " '~binding))))))
`
};