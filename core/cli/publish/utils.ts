import { exists } from "jsr:@std/fs@1.0.13";
import { writeTextFile, join, dirname } from "@platform/platform.ts";
import { globalLogger as logger } from "@core/logger.ts";
import { buildJsModule } from "./build_js_module.ts";

export type MetadataFileType = "package.json" | "deno.json" | "jsr.json";

const buildCache = new Map<string, Promise<string>>();

export function getCachedBuild(
  entryFile: string, 
  options: { verbose?: boolean; dryRun?: boolean }
): Promise<string> {
  if (!buildCache.has(entryFile)) {
    logger.debug && logger.debug(`Creating new build for ${entryFile}`);
    const buildPromise = buildJsModule(entryFile, options);
    buildCache.set(entryFile, buildPromise);
    
    buildPromise.catch(() => {
      buildCache.delete(entryFile);
    });
    
    return buildPromise;
  }
  
  logger.debug && logger.debug(`Reusing cached build for ${entryFile}`);
  return buildCache.get(entryFile)!;
}

export async function detectMetadataFiles(dir: string): Promise<Record<string, MetadataFileType | null>> {
  const result: Record<string, MetadataFileType | null> = {
    npm: null,
    jsr: null
  };

  const dirsToCheck = [dir, join(dir, "dist")];
  
  for (const checkDir of dirsToCheck) {
    if (!result.npm && await exists(join(checkDir, "package.json"))) {
      result.npm = "package.json";
      logger.debug && logger.debug(`Found package.json in ${checkDir}`);
    }

    if (!result.jsr && await exists(join(checkDir, "deno.json"))) {
      result.jsr = "deno.json";
      logger.debug && logger.debug(`Found deno.json in ${checkDir}`);
    } else if (!result.jsr && await exists(join(checkDir, "jsr.json"))) {
      result.jsr = "jsr.json";
      logger.debug && logger.debug(`Found jsr.json in ${checkDir}`);
    }
  }

  logger.debug && logger.debug(`Detected metadata files: ${JSON.stringify(result)}`);
  
  return result;
}

export function getPlatformsFromArgs(args: string[]): ("jsr" | "npm")[] {
  const allForms = new Set(['all', '-all', '--all', '-a']);
  const npmForms = new Set(['npm', '-npm', '--npm']);
  const jsrForms = new Set(['jsr', '-jsr', '--jsr']);

  let isAll = false, isNpm = false, isJsr = false;

  for (const arg of args) {
    if (allForms.has(arg)) isAll = true;
    else if (npmForms.has(arg)) isNpm = true;
    else if (jsrForms.has(arg)) isJsr = true;
  }

  if (!isAll && !isNpm && !isJsr) {
    return ["jsr"];
  }

  if (isAll) {
    return ["jsr", "npm"];
  }

  const platforms: ("jsr" | "npm")[] = [];
  if (isJsr) platforms.push("jsr");
  if (isNpm) platforms.push("npm");
  
  return platforms;
}

export async function readJSONFile(path: string): Promise<Record<string, unknown>> {
  try {
    logger.debug && logger.debug(`Reading JSON file: ${path}`);
    const text = await Deno.readTextFile(path);
    return JSON.parse(text);
  } catch (error) {
    logger.debug && logger.debug(`Error reading JSON file ${path}: ${error}`);
    return {};
  }
}

export async function writeJSONFile(path: string, data: Record<string, unknown>): Promise<void> {
  try {
    const dir = dirname(path);
    try {
      await Deno.mkdir(dir, { recursive: true });
    } catch (e) {
      // Ignore if directory already exists
    }
    
    logger.debug && logger.debug(`Writing JSON file: ${path}`);
    await Deno.writeTextFile(path, JSON.stringify(data, null, 2));
  } catch (error) {
    logger.debug && logger.debug(`Error writing JSON file ${path}: ${error}`);
    throw new Error(`Failed to write JSON file ${path}: ${error}`);
  }
}

export function incrementPatchVersion(version: string): string {
  const parts = version.split(".");
  if (parts.length !== 3) {
    return "0.0.1";
  }
  
  try {
    const major = parseInt(parts[0], 10);
    const minor = parseInt(parts[1], 10);
    let patch = parseInt(parts[2], 10);
    patch++;
    
    return `${major}.${minor}.${patch}`;
  } catch {
    return "0.0.1";
  }
}

export async function promptUser(message: string, defaultValue = ""): Promise<string> {
  const promptMessage = defaultValue 
    ? `${message} (${defaultValue}):` 
    : `${message}:`;
  
  console.log(promptMessage);
  const buf = new Uint8Array(1024);
  await Deno.stdout.write(new TextEncoder().encode(`> `));
  const n = await Deno.stdin.read(buf);
  const input = n 
    ? new TextDecoder().decode(buf.subarray(0, n)).trim() 
    : "";
  
  return input || defaultValue;
}

export async function ensureReadmeExists(distDir: string, packageName: string): Promise<void> {
  const readmePath = join(distDir, "README.md");
  if (!(await exists(readmePath))) {
    console.log(`  ‚Üí Creating default README.md`);
    await writeTextFile(
      readmePath,
      `# ${packageName}\n\n> **This is a template README automatically generated by [HQL Publish](https://github.com/boraseoksoon/hql-dev).**\n> Please update this file with your own project details!\n\n---\n\n## üì¶ About\n\nThis is a module published with [HQL](https://github.com/boraseoksoon/hql-dev).\nDescribe your project here!\n\n## üöÄ Getting Started\n\nInstall via your preferred registry:\n\n- **JSR:**\n  \`\`\`sh\n  deno add ${packageName}\n  \`\`\`\n- **NPM:**\n  \`\`\`sh\n  npm install ${packageName}\n  \`\`\`\n\n## üõ† Publishing with HQL\n\nTo publish updates, run:\n\n\`\`\`sh\nhql publish <entry-file> [jsr|npm] [version] [--dry-run]\n\`\`\`\nSee [HQL Publish Guide](https://github.com/boraseoksoon/hql-dev) for full details.\n\n## üìÑ Customizing this README\n\nEdit this file (\`README.md\`) to add your own project description, usage examples, API docs, contribution guidelines, and more.\n\n## üìö Resources\n\n- [HQL Documentation](https://github.com/boraseoksoon/hql-dev)\n- [Report Issues](https://github.com/boraseoksoon/hql-dev/issues)\n\n---\n\n## üìù License\n\n[MIT](./LICENSE) (or your preferred license)\n`,
    );
  }
}